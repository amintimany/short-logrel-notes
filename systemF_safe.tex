\documentclass{article}
\usepackage{newcent}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage[dvinames]{xcolor}
\usepackage{mathpartir}
\usepackage{pftools}
\usepackage[colorlinks]{hyperref}
\usepackage{microtype}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}

\newcommand{\gor}{~|~}
\newcommand{\fst}{\mathit{fst}}
\newcommand{\snd}{\mathit{snd}}
\newcommand{\TT}{\mathit{tt}}
\newcommand{\VAR}{\mathsf{Var}}
\newcommand{\EXP}{\mathsf{E}}
\newcommand{\VAL}{\mathsf{Val}}
\newcommand{\TYP}{\mathsf{Typ}}
\newcommand{\UNT}{()}
\newcommand{\TCTX}{\mathsf{TCtx}}
\newcommand{\ECTX}{\mathsf{ECtx}}
\newcommand{\ectx}{\mathbf{K}}
\newcommand{\empectx}{[]}
\newcommand{\defeq}{\overset{\Delta}{=}}
\newcommand{\pred}{P}
\newcommand{\predB}{Q}
\newcommand{\semtyp}[3]{\left\llbracket #2 \vdash #3 \right\rrbracket_{#1}}
\newcommand{\semErel}[1]{#1^{\textbf{E}}}
\newcommand{\semenv}{\xi}
\newcommand{\TVAR}{\mathsf{TVar}}
\newcommand{\TArg}{\_}
\newcommand{\TLam}{\Lambda}
\newcommand{\Tctx}{\Gamma}
\newcommand{\CtxTps}{\Delta}
\newcommand{\expr}{e}
\newcommand{\exprB}{f}
\newcommand{\exprC}{g}
\newcommand{\exprD}{h}
\newcommand{\val}{v}
\newcommand{\valB}{w}
\newcommand{\valC}{u}
\newcommand{\var}{x}
\newcommand{\varB}{y}
\newcommand{\varC}{z}
\newcommand{\typ}{\tau}
\newcommand{\TForall}{\forall}
\newcommand{\tvar}{\alpha}
\newcommand{\tvarB}{\delta}
\newcommand{\tvarC}{\zeta}
\newcommand{\typed}[4]{#1; #2 \vdash #3 : #4}
% \newcommand{\semtyped}{4}
\newcommand{\hstep}{\leadsto_h}
\newcommand{\step}{\leadsto}
\newcommand{\steps}{\leadsto^*}
\newcommand{\Safe}[1]{\textbf{Safe}_{#1}}


\title{Logical relations: safety of system F}
\author{Amin Timany}
\date{\today \footnote{These notes were originally released on August 17, 2016. The present version only includes minor improvements.}}

\begin{document}
\maketitle

% \paragraph{Note:} in these notes, we simply ignore the issues
% regarding the clash between variable names, e.g., capturing, by
% assuming that bound variables are renamed whenever necessary
% to avoid such problems.

\section{Language}
\subsection{Syntax}
\begin{align*}
\textit{variables} (\VAR) \hspace{1em} \phantom{\var ::={}}& \var, \varB, \varC, \dots\\
\textit{expressions} (\EXP) \hspace{1em} \expr ::={}& \var \gor \TT \gor (\expr, \expr)
\gor \fst~\expr \gor \snd~\expr \gor \lambda \var.~\expr \gor \expr~\expr
\gor \TLam~\expr \gor \expr~\TArg\\
\textit{values} (\VAL) \hspace{1em} \val ::={}& \TT \gor (\val, \val) \gor \lambda \var.~\expr
\gor \TLam~\expr
\end{align*}
The set of values is a subset of the set of expressions: $\VAL \subset \EXP$.

\subsection{Types and typing}
\begin{align*}
\textit{type variables} (\TVAR) \hspace{1em} \phantom{\expr ::={}} & \tvar, \tvarB, \tvarC, \dots\\
\textit{types} (\TYP) \hspace{1em} \typ ::={}& \tvar \gor \UNT \gor \typ \times\typ
\gor \typ \to \typ \gor \TForall \tvar.~\typ
\end{align*}
The typing context that we consider is a pair of contexts consisting of $\CtxTps$, the context for type variables, and $\Tctx$, the context for term variables.
The ``compound'' typing context (typing context for short) that we use in defining the typing rules is a pair of context written as $\CtxTps; \Tctx$.
\begin{align*}
\textit{typing context}~(\TCTX)\hspace{1em} \Tctx ::={}& \cdot \gor x : \typ, \Tctx\\
\textit{context of typing variables}~(\TCTX)\hspace{1em} \CtxTps ::={}& \cdot \gor \tvar, \CtxTps
\end{align*}
Typing rules for our system F are:\\[0.5em]
\hspace*{1em}\fbox{$\typed{\CtxTps}{\Tctx}{\expr}{\typ}$}
\begin{mathparpagebreakable}
  \inferH{T-Unit}{}{\typed{\CtxTps}{\Tctx}{\TT}{\UNT}}
  \and
  \inferH{T-Var}{\var : \typ \in \Tctx}{\typed{\CtxTps}{\Tctx}{\var}{\typ}}
  \and
  \inferH{T-Prod}{\typed{\CtxTps}{\Tctx}{\expr_1}{\typ_1} \and \typed{\CtxTps}{\Tctx}{\expr_2}{\typ_2}}{\typed{\CtxTps}{\Tctx}{(\expr_1, \expr_2)}{\typ_1 \times \typ_2}}
  \and
  \inferH{T-Fst}{\typed{\CtxTps}{\Tctx}{\expr}{\typ_1 \times \typ_2}}{\typed{\CtxTps}{\Tctx}{\fst~\expr}{\typ_1}}
  \and
  \inferH{T-Snd}{\typed{\CtxTps}{\Tctx}{\expr}{\typ_1 \times \typ_2}}{\typed{\CtxTps}{\Tctx}{\snd~\expr}{\typ_2}}
  \and
  \inferH{T-Lam}{\typed{\CtxTps}{\var : \typ_1, \Tctx}{\expr}{\typ_2}}{\typed{\CtxTps}{\Tctx}{\lambda x.~\expr}{\typ_1 \to \typ_2}}
  \and
  \inferH{T-App}{\typed{\CtxTps}{\Tctx}{\expr}{\typ_1 \to \typ_2} \and \typed{\CtxTps}{\Tctx}{\expr'}{\typ_1}}{\typed{\CtxTps}{\Tctx}{\expr~\expr'}{\typ_2}}
  \and
  \inferH{T-TLam}{\typed{\tvar, \CtxTps}{\Tctx}{\expr}{\typ} \and \tvar ~\text{ does not appear freely in }~ \Tctx}{\typed{\CtxTps}{\Tctx}{\TLam\; e}{\TForall \tvar.~\typ}}
  \and
  \inferH{T-TApp}{\typed{\CtxTps}{\Tctx}{\expr}{\TForall \tvar.~\typ}}{\typed{\CtxTps}{\Tctx}{\expr~\TArg}{\typ[\typ'/\tvar]}}
\end{mathparpagebreakable}

\subsection{Operational semantics (CBV)}
We describe the small-step call-by-value (CBV) operational semantics for system F.
In the first step we give the head reduction relation ($\hstep$).
In the second step we extend this to non-head reductions using
evaluation context ($\ECTX$).

\paragraph{Head reduction:}
\begin{align*}
\fst~(\val_1, \val_2) \hstep \val_1 \hspace{2em}
\snd~(\val_1, \val_2) \hstep \val_2 \hspace{2em}
(\lambda x.~\expr)~\val \hstep \expr[\val/\var] \hspace{2em}
(\TLam~e)~\TArg \hstep \expr
\end{align*}
Note that here $v$'s are values \emph{and not any expression}.
$e[v/x]$ is the expression $e$ where all instances of $x$ are
replaced with $v$. \emph{Remember that all substitutions are capture avoiding}.
\paragraph{Non-head reduction:} If the redex (what is being reduced) is not in the head position (see above) then evaluation contexts determine where in the term a reduction can happen.
\begin{mathpar}
  \inferrule{\expr \hstep \expr'}{\ectx[\expr] \step \ectx[\expr']}{}
\end{mathpar}
where $\ectx$ is an evaluation context, i.e., $\ectx \in \ECTX$
and $\ectx[\expr]$ is the expression where the single whole in the context $\ectx$ (see below) is substituted with $\expr$.

\paragraph{Evaluation Contexts:}
\begin{align*}
\textit{evaluation contexts}~ (\ECTX) \hspace{1em} \ectx ::={} \empectx
\gor \fst~\ectx \gor \snd~\ectx \gor (\ectx, \expr) \gor (\val, \ectx)
\gor \ectx~\expr \gor \val~\ectx \gor \ectx~\TArg
\end{align*}

\paragraph{Remark:} In the sequel, we will use the word ``context''
to refer to both typing contexts and evaluation contexts whenever
the distinction is clear from the discussion at hand.

\paragraph{Example:} The following is the only possible reduction for the expression
\[\fst~((\lambda \var.~((\lambda \varB.~ \TT)~\var, (\lambda \varB.~ \var)~\TT))~\TT)\]
showing that it reduces to $\TT$
\[
\fst~((\lambda \var.~((\lambda \varB.~ \TT)~\var, (\lambda \varB.~ \var)~\TT))~\TT) \step
\fst~((\lambda \varB.~ \TT)~\TT, (\lambda \varB.~ \TT)~\TT) \step
\fst~(\TT, (\lambda \varB.~ \TT)~\TT)
\]
\[
\step \fst~(\TT, \TT) \step \TT
\]

% \paragraph{Exercise:} Determine the evaluation context for each step of the reduction above.

We use $\steps$ to denote reflexive and transitive closure of $\step$.

\section{Type safety}
We say a language is type safe or has the type safety property if:
\[
\forall \expr, \typ.\; \typed{\cdot}{\cdot}{\expr}{\typ} \implies \mathbf{Safe}(\expr)
\]
where
\[
\mathbf{Safe}(\expr) \defeq \forall \expr'.~ \expr \steps \expr'
\implies \expr' \in \VAL \lor \exists \expr''.~\expr\step \expr''
\]
For system F, type safety can be proven using the well-known progress and preservation technique. In these notes we instead use the logical relations technique which also allows us to derive some ``theorems for free''.

\section{Logical relations (First Attempt)}
It seems only natural, given the statement of type safety, \ie{} $\expr : \typ$ implies safety, to try to prove this statement by induction on the typing derivation.
As we will see below, applying induction directly on the statement of type safety does not allow us to prove it.

What we do in this section is attempting to apply induction to type safety and each time this fails we change (stengthen) the statement of the theorem until we can successfully apply induction. In each step, we show that the statement that we consider implies type safety.

\paragraph{Attempt 1:}
If we simply apply induction on the the typing derivation to prove
type safety as stated above, we immediately run into a problem
in the case \ruleref{T-App}. In this case we have to prove $\mathbf{Safe}(\expr~\expr')$ and the only thing that we know is that $\mathbf{Safe}(\expr)$ and $\mathbf{Safe}(\expr')$ both hold.
Particularly, notice the case where $\expr = \lambda \var.~\exprB$ for some expression $\exprB$.
Since $\expr$ is already a value, its safety says absolutely nothing about $\exprB$.
Note that in this case, we can have $\expr' \steps \val'$ which means that $\expr~\expr' \steps (\lambda \var.~\exprB)~\val' \step \exprB[\val'/\var]$.
In this case, we do not have enough information to show that
\[
\exprB[\val'/\var] \in \VAL \lor \exists \exprC.~\exprB[\val'/\var] \step \exprC
\]
This is the key observation motivating logical relations.
It is not sufficient to know that expressions are safe.
We need in addition to know that the resulting value has certain properties depending on its type.
For instance, if $\expr$ is an expression of function type $\typ_1 \to \typ_2$, then any value $\val$ obtained from $\expr$ must be safe when applied to a value of type $\typ_1$ and moreover, the resulting value must satisfy the appropriate properties of the type $\typ_2$.
The main idea of logical relations is simply just that.
We define relations (in this case a \emph{unary} relation, \ie{}, a predicate) by induction on the types of the programming language.
This predicate, in the case of function types (whose values are lambdas) specifically states that terms are in the predicate if they
take terms in the predicate for the domain to terms in the predicate for the codomain.

\paragraph{Note:} A similar issue is not observed in the case of \ruleref{T-TApp}.
In that case, $(\TLam~\expr)~\TArg \step \expr$ and the safety of $\expr$ is simply the induction hypothesis.

\section{Parameterized Safety}
\label{sec:safety}

Above, we argued that logical relations for safety of our system would essentially state that an expression in the relation must be safe, and in addition, the resulting value must satisfy certain properties.
In order to formalize this idea we introduce the following parameterized safety predicate (parameterized over a predicate on values) which we will later use in the definition of logical relations.
\begin{align*}
  \Safe{\pred}(\expr) \defeq{}& \forall \expr'.~ \expr \steps \expr' \implies (\expr' \in \VAL \land P(\expr')) \lor \exists \expr''.~\expr \step \expr''
\end{align*}
Note how the predicate $\Safe{\pred}(\expr)$, regardless of the predicate $\pred$, implies $\Safe{}(\expr)$ as defined earlier.
The parameterized safety predicate satisfies the following interesting properties:

\newtheorem*{safevallemma}{Safe-Val}
\newtheorem*{safebindlemma}{Safe-Bind}
\newtheorem*{safesteplemma}{Safe-Step}
\newtheorem*{safemonolemma}{Safe-Mono}

\begin{safemonolemma}
  \makeatletter\def\@currentlabel{Safe-Mono}\makeatother
  \label{lem:safemono}
  Let $\expr$ be an expression and $\pred$ and $\predB$ be two predicate on values, we have
  \[(\forall \val.\; \pred(\val) \implies \predB(\val)) \implies \Safe{\pred}(\expr) \implies \Safe{\predB}(\expr)\]
\end{safemonolemma}


\begin{safevallemma}
  \makeatletter\def\@currentlabel{Safe-Val}\makeatother
  \label{lem:safeval}
  Let $\val$ be a value and $\pred$ be a predicate on values, we have
  \[\pred(\val) \implies \Safe{\pred}(\val)\]
\end{safevallemma}

\begin{safebindlemma}
  \makeatletter\def\@currentlabel{Safe-Bind}\makeatother
  \label{lem:safebind}
  Let $\ectx$ be an evaluation context, $\expr$ be an expression, and $\pred$ be a predicate on values.
  The following holds:
  \[\Safe{\predB}(\expr) \land (\forall \val.\; \predB(\val) \implies \Safe{\pred}(\ectx[\val])) \implies \Safe{\pred}(\ectx[\expr])\]
\end{safebindlemma}

The property \ref{lem:safebind} states that to show that $\ectx[\expr]$ is safe, it suffices to show that $\ectx[\val]$ is safe where $\val$ is the value obtained from executing $\expr$.
This crucially relies on the fact that any execution of $\ectx[\expr]$ must necessarily first execute $\expr$, and only when it has evaluated to a value $\val$ continue with execution of $\ectx[\val]$.

\begin{safesteplemma}
  \makeatletter\def\@currentlabel{Safe-Step}\makeatother
  \label{lem:safestep}
  Let $\expr$ and $\expr'$ be two expressions and $\pred$ be a predicate on values. We have the following:
  \[\expr \step \expr' \land \Safe{\pred}(\expr') \implies \Safe{\pred}(\expr) \]
\end{safesteplemma}

Note the order of things in \ref{lem:safestep} above.
Whenever $\expr \step \expr'$, $\Safe{\pred}(\expr')$ implies $\Safe{\pred}(\expr)$.
This means that for instance if we have to show $\Safe{\pred}((\lambda \var.\; \expr)~\val)$ it suffices to show $\Safe{\pred}(\expr[\val/\var])$.
The proof of this theorem essentially relies on the fact that the operational semantics of our programming language is deterministic.
That is, when $\expr \step \expr'$ we have that $\expr'$ is the only possible expression that $\expr$ evaluates to in one step.

\section{Logical Relations}
We define the predicates associated with types in two stages.
We first define a predicate $\semErel{\pred}$ on expressions given a predicate $\pred$ on values which essentially the parameterized safety predicate we defined above --- this is essentially a new, more concise, and more consistent notation for the parameterized safety relation.
\begin{align*}
  \semErel{\pred}(\expr) \defeq{}& \Safe{\pred}(\expr)
\end{align*}
This relation is essentially the safety predicate which in addition states then the resulting value must in addition also satisfy $\pred$.
We then define a set of predicates on values defined recursively on types.
Notice that since these predicates are defined by recursion on types and types can have free variables, we need to consider the interpretation of free type variables.
Hence, the predicates the we define on values, and therefore also the predicates on all expressions, must be decorated with a mapping $\semenv$ from type variables to predicates.
Intuitively, $\semenv$ maps each type variable to its associated predicate on values.

\paragraph{Predicates on values $\left(\semtyp{\semenv}{\CtxTps}{\typ}\right)$:}
Let us have a firs na\"ive attempt at defining these logical
predicates.
\begin{align*}
\semtyp{\semenv}{\CtxTps}{\tvar} \defeq{}& \semenv(\tvar)\\
\semtyp{\semenv}{\CtxTps}{\UNT}(\val) \defeq{}& \val = \TT\\
\semtyp{\semenv}{\CtxTps}{\typ_1 \times \typ_2}(\val) \defeq{}& \exists \val_1, \val_2.~\val = (\val_1, \val_2) \land
\semtyp{\semenv}{\CtxTps}{\typ_1}(\val_1) \land \semtyp{\semenv}{\CtxTps}{\typ_1}(\val_2)\\
\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}(\val) \defeq{}& \exists \expr, \val = \lambda \var.~\expr\land
\forall \val'.~\semtyp{\semenv}{\CtxTps}{\typ_1}(\val') \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\val/\var])\\
\semtyp{\semenv}{\CtxTps}{\TForall \tvar.~\typ}(\var) \defeq{}& \exists \expr, \val = \TLam~\expr\land
\forall \typ'.~\semErel{\semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}}(\expr) \hspace{1em} {\color{red}(incorrect)}
\end{align*}
where $[\tvar \mapsto P]\semenv$ is extending the mapping $\semenv$ by additionally associating $\tvar$ to $P$.

The problem with the case $\semtyp{\semenv}{\CtxTps}{\TForall \tvar.~\typ}$ is that in this case the type $\typ[\typ'/\tvar]$ is not \emph{smaller} than the type $\TForall \tvar.~\typ$ which makes the inductive definition above invalid.
We can for example take $\typ'$ to be $\TForall \tvar.~\typ$ itself.
The unrestricted choice of $\typ'$, \ie{}, the universal quantification, is the essence of the problem.
Yet, it is necessary as the typing rule \ruleref{T-TApp} allows us to instantiate a polymorphic type with any arbitrary type $\typ'$.

There are two ways that we can address this issue.
The first approach is to restrict the range of $\typ'$ in the rule \ruleref{T-TApp}.
We can do this by introducing an infinite hierarchy of so-called \emph{universes}:
\[\mathsf{Tp}_0, \mathsf{Tp}_1, \dots\]
We would then restrict that $\mathsf{Tp}_0$ has no types that include polymorphic types (types of the form $\TForall \tvar.~\typ$).
Furthermore, for any type $\TForall \tvar.~\typ$ that belongs to $\mathsf{Tp}_{n+1}$, only a $\typ'$ in $\mathsf{Tp}_i$ for $i \le n$ can be used to substitute $\tvar$ in the typing rules.
This allows us define the logical relations of system F by recursion on the hierarchy of universes as well as the structure of types.
This would allow us to prove type safety (and when the logical predicates are adjusted appropriately) to prove safety for system F --- though it would not allow us to derive ``theorems for free''!.
This way of treating polymorphic types is usually referred to as \emph{predicative} polymorphism, as opposed to the \emph{impredicative} polymorphism of system F.
This is the approach taken in the underlying languages of proof assistants such as Coq and Agda.

Here, we adjust our logical relations to work with the impredicative polymorphism system F.
This is based on an insight by J. C. Reynolds, who alongside J. Y. Girard (independently) discovered system F.
This insight is that the semantics (predicate) of polymorphic types should not quantifying over all of the types of the language but rather
they must quantifying over all possible semantic types, \ie{}, all possible predicates over values.
Note that this also includes all the predicates that are associated to the types of our language.
The new logical relations for system F is defined as follows:

\begin{align*}
\semtyp{\semenv}{\CtxTps}{\tvar} \defeq{}& \semenv(\tvar)\\
\semtyp{\semenv}{\CtxTps}{\UNT}(\val) \defeq{}& v = \TT\\
\semtyp{\semenv}{\CtxTps}{\typ_1 \times \typ_2}(\val) \defeq{}& \exists \val_1, \val_2.~\val = (\val_1, \val_2) \land
\semtyp{\semenv}{\CtxTps}{\typ_1}(\val_1) \land \semtyp{\semenv}{\CtxTps}{\typ_1}(\val_2)\\
\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}(\val) \defeq{}& \exists \expr, \val = \lambda \var.~\expr \land
\forall \val'.~\semtyp{\semenv}{\CtxTps}{\typ_1}(\val') \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\val'/\var])\\
\semtyp{\semenv}{\CtxTps}{\forall \tvar.~\typ}(\val) \defeq{}& \exists \expr, \val = \TLam~\expr\land
\forall \pred \in 2^{\VAL}.~\semErel{\semtyp{[\tvar \mapsto \pred]\semenv}{\tvar, \CtxTps}{\typ}}(\expr)
\end{align*}

\paragraph{Note:} Note that we are implicitly assuming that the domain of the partial mapping $\semenv$ in $\semtyp{\semenv}{\CtxTps}{\typ}$ is always $\CtxTps$.

Before we proceed, we state two important properties of our logical relations.

The following lemma states that as far as the logical relation is concerned substitution of a type $\typ'$ in a type $\typ$ is equivalent to associating its corresponding logical relation to the corresponding free type variable in the mapping that interprets free type variables.
\newtheorem*{logrelsubst}{LogRel-Subst}
\begin{logrelsubst}
  \makeatletter\def\@currentlabel{LogRel-Subst}\makeatother
  \label{lem:logrelsubst}
  The following holds for any $\semenv$, $\CtxTps$, $\val$, $\typ$, $\typ'$, $\tvar$:
  \[ \semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}(\val) \iff \semtyp{[\tvar \mapsto \semtyp{\semenv}{\CtxTps}{\typ'}]\semenv}{\CtxTps}{\typ}(\val) \]
\end{logrelsubst}
\begin{proof}
Straightforward induction on structure of type $\typ$.
\end{proof}

The following lemma states that, perhaps obviously, the relation for a type $\typ$ where $\tvar$ does not appear freely does not depend on the predicate associated with $\tvar$ in the mapping that interprets free type variables.
\newtheorem*{logrelweaken}{LogRel-Weaken}
\begin{logrelweaken}
  \makeatletter\def\@currentlabel{LogRel-Weaken}\makeatother
  \label{lem:logrelweaken}
  The following holds for any $\pred$ $\semenv$, $\CtxTps$, $\val$, $\typ$, and any $\tvar$ the \textbf{does not} appear freely in $\typ$:
  \[ \semtyp{\semenv}{\CtxTps}{\typ}(\val) \iff \semtyp{[\tvar \mapsto \pred]\semenv}{\tvar, \CtxTps}{\typ}(\val) \]
\end{logrelweaken}
\begin{proof}
Straightforward induction on structure of type $\typ$.
\end{proof}

The logical relations above are defined over closed terms, \ie{}, programs where no free (term) variables appear.
We extend the defined relations to open terms by substituting for the free variables values in the logical relations for the appropriate type.\footnote{It is an interesting exercise to work out what goes wrong if we do not extend the relation to open terms. That is, if we only have a relation on closed terms. After all, the type safety theorem regards only closed terms. \emph{Hint: check the induction hypothesis we obtain for the case of \ruleref{T-Lam}.} }
For this purpose we define when a sequence of values $\mathit{vs}$ is in the corresponding predicates for the types in a context $\Tctx$, written as $\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs})$.

\paragraph{The relation on sequences of values}
A sequence of terms $\mathit{vs} = \val_1, \dots,\val_n$ is said to be in the predicates for a context $\Tctx = \var_1 : \typ_1,\dots, \var_n : \typ_n$ under the context of type variables $\CtxTps$ (with interpretation $\semenv$), written as $\semtyp{\semenv}{\CtxTps}{\Tctx}(vs)$ if
\begin{align*}
\semtyp{\semenv}{\CtxTps}{\cdot}(\mathit{vs}) \defeq{}& |\mathit{vs}| = 0\\
\semtyp{\semenv}{\CtxTps}{\var : \typ, \Tctx}(\mathit{vs}) \defeq{}& \exists \val, \mathit{vs'}.\; \mathit{vs} = \val, \mathit{vs'} \land \semtyp{\semenv}{\CtxTps}{\typ}(\val) \land \semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs'})
\end{align*}

The following lemma simply extends lemma \ref{lem:logrelweaken} to the relation on sequences of values.
\newtheorem*{logrelseqweaken}{LogRel-Seq-Weaken}
\begin{logrelseqweaken}
  \makeatletter\def\@currentlabel{LogRel-Seq-Weaken}\makeatother
  \label{lem:logrelseqweaken}
  The following holds for any $\pred$ $\semenv$, $\CtxTps$, $\mathit{vs}$, $\Tctx$, and any $\tvar$ the \textbf{does not} appear freely in $\Tctx$:
  \[ \semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \iff \semtyp{[\tvar \mapsto \pred]\semenv}{\tvar, \CtxTps}{\Tctx}(\mathit{vs}) \]
\end{logrelseqweaken}
\begin{proof}
A simple consequence of \ref{lem:logrelweaken} which follows by a simple induction on the length of $\Tctx$
\end{proof}

\paragraph{Attempt 2:} In this final attempt we prove the following theorem, known as the fundamental theorem (or fundamental lemma) of logical relations.

\newtheorem*{fundamentaltheorem}{Fundamental Theorem}

\begin{fundamentaltheorem}[of logical relations]
  \makeatletter\def\@currentlabel{Fundamental Theorem}\makeatother
  \label{thm:fundamental}
For any $e$, $\CtxTps$, $\Tctx$ and $\typ$ such that $\typed{\CtxTps}{\Tctx}{\expr}{\typ}$ we have:
\[
\forall \semenv, \mathit{vs}. ~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
\semErel{\semtyp{\semenv}{\CtxTps}{\typ}}(\expr[\mathit{vs}/\mathit{xs}])
\]
where $\mathit{xs}$ is the sequence of variables of $\Tctx$ and $\expr[\mathit{vs}/\mathit{xs}]$ is a shorthand for $\expr[\val_1, \dots, \val_n/\var_1, \dots, \var_n]$ which is the term $\expr$ where $\var_i$'s are substituted with $\val_i$'s simultaneously.
\end{fundamentaltheorem}

\begin{proof}
By induction on the derivation of $\typed{\CtxTps}{\Tctx}{\expr}{\typ}$.
Here we prove the cases \textsc{App}, \textsc{TApp},
\textsc{Lam} and \textsc{TLam}.
We leave the rest of the cases as an easy exercise.

\paragraph{Case \ruleref{T-App}:}
Let us consider the case of \ruleref{T-App} which was problematic in the first attempt.
We need to show that
\begin{align}
  \label{eq:fund-app-main}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\mathit{vs}/\mathit{xs}]~\expr'[\mathit{vs}/\mathit{xs}])
\end{align}
holds knowing that both induction hypotheses
\begin{align}
  \label{eq:fund-app-ih1}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}}(\expr[\mathit{vs}/\mathit{xs}])
\end{align}
and
\begin{align}
  \label{eq:fund-app-ih2}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ_1}}(\expr'[\mathit{vs}/\mathit{xs}])
\end{align}
hold.
For the rest of this case, we assume some arbitrary but fixed $\semenv$ and $\mathit{vs}$.
We need to show that
\begin{align}
  \label{eq:fund-app-to-show-1}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\mathit{vs}/\mathit{xs}]~\expr'[\mathit{vs}/\mathit{xs}])
\end{align}
Since $\empectx~\expr'[\mathit{vs}/\mathit{xs}]$ is an evaluation context, we can apply \ref{lem:safebind} after which we need to show that
\begin{align}
  \label{eq:fund-app-to-show-2}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\val~\expr'[\mathit{vs}/\mathit{xs}])
\end{align}
for a value $\val$ for which we have $\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}(\val)$ (due to \eqref{eq:fund-app-ih1} above).
The latter implies that $\val = \lambda \var.\; \exprB$ for some expression $\exprB$ for which we have
\begin{align}
  \label{eq:fund-app-lam-body}
  \forall \valB.~\semtyp{\semenv}{\CtxTps}{\typ_1}(\valB) \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\exprB[\valB/\var])
\end{align}
Now, to show that \eqref{eq:fund-app-to-show-2} holds, we can apply the \ref{lem:safebind} again, this time with the evaluation context $\val~\empectx$.
This leaves us to show
\begin{align}
  \label{eq:fund-app-to-show-3}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ_2}}((\lambda \var.\; \exprB)~\valB)
\end{align}
for a value $\valB$ for which we have
\begin{align}
  \label{eq:fund-app-func-arg}
  \semtyp{\semenv}{\CtxTps}{\typ_1}(\valB)
\end{align}
(due to \eqref{eq:fund-app-ih2} above).
To show \eqref{eq:fund-app-to-show-3} above, by \ref{lem:safestep}, it suffices to show
\begin{align}
  \label{eq:fund-app-to-show-4}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\exprB[\valB/\var])
\end{align}
Which just follows by \eqref{eq:fund-app-lam-body} as we have \eqref{eq:fund-app-func-arg}.

\paragraph{Case \ruleref{T-Lam}:}
We need to show that
\begin{align}
  \label{eq:fund-lam-main}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}}(\lambda \var.\; \expr[\mathit{vs}/\mathit{xs}])
\end{align}
holds knowing that the following induction hypothesis holds:
\begin{align}
  \label{eq:fund-lam-ih}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\var : \typ_1, \Tctx}(\mathit{vs}) \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\mathit{vs}/\mathit{xs}])
\end{align}
That is, we need to show
\begin{align}
  \label{eq:fund-lam-to-show-1}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}}(\lambda \var.\; \expr[\mathit{vs}/\mathit{xs}])
\end{align}
For a sequence of values $\mathit{vs}$ for which we have
\begin{align}
  \label{eq:fund-lam-env-rel}
  \semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs})
\end{align}
Since the term $\lambda \var.\; \expr[\mathit{vs}/\mathit{xs}]$ is already a value, by \ref{lem:safeval}, we only need to show
\begin{align}
  \label{eq:fund-lam-to-show-2}
  \semtyp{\semenv}{\CtxTps}{\typ_1 \to \typ_2}(\lambda \var.\; \expr[\mathit{vs}/\mathit{xs}])
\end{align}
After unfolding the logical relations, and some minor simplifications, we need to show that
\begin{align}
  \label{eq:fund-lam-to-show-3}
  \forall \val'.~\semtyp{\semenv}{\CtxTps}{\typ_1}(\val') \implies \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\mathit{vs}/\mathit{xs}][\val'/\var])
\end{align}
We proceed by introducing the universal quantifier and the implication in \eqref{eq:fund-lam-to-show-3} above.
Therefore, it remains to show
\begin{align}
  \label{eq:fund-lam-to-show-4}
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\mathit{vs}/\mathit{xs}][\val/\var])
\end{align}
for some value $\val'$ for which we have
\begin{align}
  \label{eq:fund-lam-applied-arg}
  \semtyp{\semenv}{\CtxTps}{\typ_1}(\val')
\end{align}
Now, putting \eqref{eq:fund-lam-applied-arg} and \eqref{eq:fund-lam-env-rel} together we obtain
\begin{align}
  \label{eq:fund-lam-extended-env-rel}
  \semtyp{\semenv}{\CtxTps}{\var : \typ_1,\Tctx}(\val, \mathit{vs})
\end{align}
Subsequently, by applying \eqref{eq:fund-lam-ih} to \eqref{eq:fund-lam-extended-env-rel} we obtain
\begin{align}
  \label{eq:fund-lam-ih-consequence}
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ_2}}(\expr[\val', \mathit{vs}/\var, \mathit{xs}])
\end{align}
Which is the same as \eqref{eq:fund-lam-to-show-4} above we had to prove.

\paragraph{Case \ruleref{T-TApp}:}
We need to show that
\begin{align}
  \label{eq:fund-tapp-main}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
  \semErel{\semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}}(\expr[\mathit{vs}/\mathit{xs}]~\TArg)
\end{align}
holds knowing that the following induction hypothesis holds:
\begin{align}
  \label{eq:fund-tapp-ih}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies \semErel{\semtyp{\semenv}{\CtxTps}{\TForall \tvar.\; \typ}}(\expr[\mathit{vs}/\mathit{xs}])
\end{align}
That is, we need to show
\begin{align}
  \label{eq:fund-tapp-to-show-1}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}}(\expr[\mathit{vs}/\mathit{xs}]~\TArg)
\end{align}
For a sequence of values $\mathit{vs}$ for which we have
\begin{align}
  \label{eq:fund-tapp-env-rel}
  \semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs})
\end{align}
Since $\ectx~\TArg$ is an evaluation context we apply \ref{lem:safebind} with $\ectx$ being this evaluation context.
Hence, we have to show
\begin{align}
  \label{eq:fund-tapp-to-show-2}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}}(\val~\TArg)
\end{align}
for some value $\val$ for which we know $\val = \TLam\; \exprB$ such that
\begin{align}
  \label{eq:fund-tapp-the-poly-term}
  \forall \pred \in 2^{\VAL}.~\semErel{\semtyp{[\tvar \mapsto \pred]\semenv}{\tvar, \CtxTps}{\typ}}(\exprB)
\end{align}
Now, we apply \ref{lem:safestep} to \eqref{eq:fund-tapp-to-show-2} which leaves us to show
\begin{align}
  \label{eq:fund-tapp-to-show-3}
  \Safe{\semtyp{\semenv}{\CtxTps}{\typ[\typ'/\tvar]}}(\exprB)
\end{align}
This, however, due to the equivalence \ref{lem:logrelsubst} and \ref{lem:safemono}, is a simple consequence of \eqref{eq:fund-tapp-the-poly-term} by taking $\pred$ to be $\semtyp{\semenv}{\CtxTps}{\typ'}$.

\paragraph{Case \ruleref{T-TLam}:}
We need to show that
\begin{align}
  \label{eq:fund-tlam-main}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs}) \implies
  \semErel{\semtyp{\semenv}{\CtxTps}{\TForall \tvar.\; \typ}}(\TLam\; \expr[\mathit{vs}/\mathit{xs}])
\end{align}
holds knowing that the following induction hypothesis holds:
\begin{align}
  \label{eq:fund-tlam-ih}
  \forall \semenv, \mathit{vs}.~\semtyp{\semenv}{\tvar, \CtxTps}{\Tctx}(\mathit{vs}) \implies \semErel{\semtyp{\semenv}{\tvar, \CtxTps}{\typ}}(\expr[\mathit{vs}/\mathit{xs}])
\end{align}
Furthermore, we know that $\tvar$ does not appear freely in $\Tctx$.
Since $\TLam\; \expr[\mathit{vs}/\mathit{xs}]$ is already a value, by \ref{lem:safeval}, we only need to show
\begin{align}
  \label{eq:fund-to-show-1}
  \semtyp{\semenv}{\CtxTps}{\TForall \tvar.\; \typ}(\TLam\; \expr[\mathit{vs}/\mathit{xs}])
\end{align}
For some a sequence of values $\mathit{vs}$ for which we have
\begin{align}
  \label{eq:fund-tapp-env-rel}
  \semtyp{\semenv}{\CtxTps}{\Tctx}(\mathit{vs})
\end{align}
After unfolding the logical relations, and some minor simplifications, we need to show that
\begin{align}
  \label{eq:fund-lam-to-show-2}
  \semErel{\semtyp{[\tvar \mapsto P]\semenv}{\tvar, \CtxTps}{\typ}}(\expr[\mathit{vs}/\mathit{xs}])
\end{align}
for an arbitrary predicate $\pred \in 2^{\VAL}$ on values.
Now, by \eqref{eq:fund-tlam-ih}, we only need to show
\begin{align}
  \label{eq:fund-tapp-to-show-3}
  \semtyp{[\tvar \mapsto \pred]\semenv}{\tvar, \CtxTps}{\Tctx}(\mathit{vs})
\end{align}
which by  \ref{lem:logrelseqweaken} is exactly equivalent to \eqref{eq:fund-tapp-env-rel} above.
\end{proof}

\newtheorem*{typesafety}{Type Safety}

\begin{typesafety}
  \makeatletter\def\@currentlabel{Type Safety}\makeatother
  \label{thm:typesafety}
  For any expression $\expr$ and type $\typ$ for which $\typed{\cdot}{\cdot}{\expr}{\typ}$ we have
  \[ \Safe{}(\expr) \]
\end{typesafety}

\begin{proof}
  By the \ref{thm:fundamental}, since $\typed{\cdot}{\cdot}{\expr}{\typ}$ we have
  \[ \forall \semenv, \mathit{vs}. ~\semtyp{\semenv}{\cdot}{\cdot}(\mathit{vs}) \implies
    \semErel{\semtyp{\semenv}{\cdot}{\typ}}(\expr[\mathit{vs}/\mathit{xs}]) \]
  We simply take $\semenv$ to by the empty map and $\mathit{vs}$ to be the empty sequence of values.
  Consequently, we obtain
  \[ \semErel{\semtyp{\emptyset}{\cdot}{\typ}}(\expr) \]
  or, written differently
  \[ \Safe{\semtyp{\emptyset}{\cdot}{\typ}}(\expr) \]
  which immediately implies $\Safe{}(\expr)$ as required.
\end{proof}

\section{Parametericity and theorems for free}
The \ref{thm:fundamental} that we proved above has a number of interesting consequences other than \ref{thm:typesafety}.
In particular, it says that the types that we quantify over in our language when we write polymorphic programs are not just the types that are syntactically representable in the type system of the language but are rather any conceivable semantic type, \ie{}, any predicate over values.
This ingenious idea of Reynolds has deep and very interesting consequences.
Here, we only see a couple of very simple consequences of this idea which we can obtain even with our rather weak logical relations which merely establishes safety of system F.

One in particular can use this theorem to derive so-called \emph{free theorems} about polymorphic programs.
This is due to the fact that they follow rather easily from the \ref{thm:fundamental}.

\newtheorem{freetheorem}{Free Theorem}

\begin{freetheorem}[the polymorphic type of the identity function]
Any term of type $\forall \tvar.~\tvar \to \tvar$ is the identity function. That is,
\[
\forall \expr.\; \typed{\cdot}{\cdot}{\expr}{\forall \tvar.~\tvar \to \tvar} \implies \Safe{\mathit{Eq}_{\val}}((\expr~\TArg)~\val)
\]
where
\[ \mathit{Eq}_{\val}(\valB) \defeq{} \valB = \val \]
\end{freetheorem}

\begin{proof}
Let us assume $\typed{\cdot}{\cdot}{\expr}{\forall \tvar.~\tvar \to \tvar}$ for some arbitrary expression $\expr$.
We need to show
\begin{align}
  \label{eq:poly-id-to-show-1}
  \Safe{\mathit{Eq}_{\val}}((\expr~\TArg)~\val)
\end{align}
By the \ref{thm:fundamental} we know that
\begin{align}
  \label{eq:poly-id-fund}
\forall \semenv.~ \semErel{\semtyp{\semenv}{\cdot}{\forall \tvar.~\tvar \to \tvar}}(\expr)
\end{align}
By taking the empty mapping for $\semenv$ and unfolding the logical relation \ref{eq:poly-id-fund} implies
\begin{align}
  \label{eq:poly-id-fund-1}
  \Safe{\semtyp{\emptyset}{\cdot}{\forall \tvar.~\tvar \to \tvar}}(\expr)
\end{align}
By using \eqref{eq:poly-id-fund-1} above and \ref{lem:safebind} (since $(\empectx~\TArg)~\val$ is an evaluation context) it suffices to show
\begin{align}
  \label{eq:poly-id-to-show-2}
  \Safe{\mathit{Eq}_{\val}}((\valB~\TArg)~\val)
\end{align}
for some value $\valB = \TLam\; \exprB$ and some $\exprB$ for which we have
\begin{align}
  \label{eq:poly-id-fund-2}
  \forall \pred \in 2^{\VAL}.~\semErel{\semtyp{[\tvar \mapsto \pred]\emptyset}{\tvar, \cdot}{\tvar \to \tvar}}(\exprB)
\end{align}
which can be simplified to
\begin{align}
  \label{eq:poly-id-fund-3}
  \forall \pred \in 2^{\VAL}.~\Safe{\semtyp{[\tvar \mapsto pred]\emptyset}{\tvar, \cdot}{\tvar \to \tvar}}(\exprB)
\end{align}
Now, by \ref{lem:safestep} we are left to show that
\begin{align}
  \label{eq:poly-id-to-show-3}
  \Safe{\mathit{Eq}_{\val}}(\exprB~\val)
\end{align}
Again, by applying \ref{lem:safebind}, this time together with \eqref{eq:poly-id-fund-3} and taking $\pred$ to be $\mathit{Eq}_{\val}$, we only have to show
\begin{align}
  \label{eq:poly-id-to-show-4}
  \Safe{\mathit{Eq}_{\val}}(\valB~\val)
\end{align}
for some value $\valB$ and $\exprC$ such that $\valB = \lambda \var.\; \exprC$ and we have
\begin{align}
  \label{eq:poly-id-fund-4}
  \semtyp{[\tvar \mapsto \mathit{Eq}_{\val}]\emptyset}{\tvar, \cdot}{\tvar \to \tvar}(\valB)
\end{align}
or equivalently
\begin{align}
  \label{eq:poly-id-fund-5}
  \forall \valC.~\semtyp{[\tvar \mapsto \mathit{Eq}_{\val}]\emptyset}{\tvar, \cdot}{\tvar}(\valC) \implies \semErel{\semtyp{[\tvar \mapsto \mathit{Eq}_{\val}]\emptyset}{\tvar, \cdot}{\tvar}}(\exprC[\valC/\var])
\end{align}
which we can simplify further
\begin{align}
  \label{eq:poly-id-fund-6}
  \forall \valC.~\mathit{Eq}_{\val}(\valC) \implies \semErel{\mathit{Eq}_{\val}}(\exprC[\valC/\var])
\end{align}
and still further
\begin{align}
  \label{eq:poly-id-fund-7}
  \forall \valC.~\mathit{Eq}_{\val}(\valC) \implies \Safe{\mathit{Eq}_{\val}}(\exprC[\valC/\var])
\end{align}
Now, by \ref{lem:safestep} and the fact $\valB = \lambda \var.\; \exprC$, the following suffices to show \eqref{eq:poly-id-to-show-4}:
\begin{align}
  \label{eq:poly-id-to-show-4}
  \Safe{\mathit{Eq}_{\val}}(\exprC[\valC/\var])
\end{align}
which is a simple consequence of \eqref{eq:poly-id-fund-7}.
\end{proof}

\begin{freetheorem}[the empty type]
Any term of type $\forall \tvar.~\tvar$ must necessarily diverge. That is,
\[
\forall \expr, \typed{\cdot}{\cdot}{\expr}{\forall \tvar.~\tvar} \implies \Safe{\emptyset}(\expr~\TArg)
\]
\end{freetheorem}

\begin{proof}
Let us assume $\typed{\cdot}{\cdot}{\expr}{\forall \tvar.~\tvar}$ for some arbitrary expression $\expr$.
We need to show
\begin{align}
  \label{eq:poly-emp-to-show-1}
  \Safe{\emptyset}(\expr~\TArg)
\end{align}
By the \ref{thm:fundamental} we know that
\begin{align}
  \label{eq:poly-emp-fund}
  \forall \semenv.~ \semErel{\semtyp{\semenv}{\cdot}{\forall \tvar.~\tvar}}(\expr)
\end{align}
By taking the empty mapping for $\semenv$ and unfolding the logical relation \ref{eq:poly-emp-fund} implies
\begin{align}
  \label{eq:poly-emp-fund-1}
  \Safe{\semtyp{\emptyset}{\cdot}{\forall \tvar.~\tvar}}(\expr)
\end{align}
By using \eqref{eq:poly-emp-fund-1} above and \ref{lem:safebind} (since $\empectx~\TArg$ is an evaluation context) it suffices to show
\begin{align}
  \label{eq:poly-emp-to-show-2}
  \Safe{\emptyset}(\valB~\TArg)
\end{align}
for some value $\valB$ and $\exprB$ such that $\valB = \TLam\; \exprB$ and we have
\begin{align}
  \label{eq:poly-emp-fund-2}
  \forall \pred \in 2^{\VAL}.~\semErel{\semtyp{[\tvar \mapsto \pred]\emptyset}{\tvar, \cdot}{\tvar}}(\exprB)
\end{align}
which can be simplified to
\begin{align}
  \label{eq:poly-emp-fund-3}
  \forall \pred \in 2^{\VAL}.~\Safe{\semtyp{[\tvar \mapsto \pred]\emptyset}{\tvar, \cdot}{\tvar}}(\exprB)
\end{align}
and still further simplified to
\begin{align}
  \label{eq:poly-emp-fund-4}
  \forall \pred \in 2^{\VAL}.~\Safe{\pred}(\exprB)
\end{align}
Now, by \ref{lem:safestep} we are left to show that
\begin{align}
  \label{eq:poly-id-to-show-3}
  \Safe{\emptyset}(\exprB)
\end{align}
which is a simple consequence of \eqref{eq:poly-emp-fund-4} when we take $\pred$ to be $\emptyset$.
\end{proof}

\section{Normalization of system F}
\label{sec:norm-syst-f}

\newcommand{\Normalizes}[1]{\mathbf{Normalizes}_{#1}}

We can define the normalization property as follows:
\begin{align*}
  \Normalizes{}(\expr) \defeq{} \exists \val.\; \expr \steps \val
\end{align*}
Corresponding to normalization, we can define parameterized normalization predicate as follows:
\begin{align*}
  \Normalizes{\pred}(\expr) \defeq{} \exists \val.\; \expr \steps \val \land \pred(\val)
\end{align*}
It is not too difficult to show counterparts of \ref{lem:safemono}, \ref{lem:safeval}, \ref{lem:safebind}, and \ref{lem:safestep} for the parameterized normalization predicate.
Hence, we can set up logical relations analogous to those for type safety above where we replace $\Safe{\pred}$ by $\Normalizes{\pred}$.
In fact, the proof of the fundamental theorem for these logical relations will also be entirely analogous to our proof of \ref{thm:fundamental} above.
As a result, similarly to the \ref{thm:typesafety} theorem above, we obtain a normalization theorem which would state that any closed well-typed program normalizes to a value.

\end{document}
